import { Component, Input, ChangeDetectionStrategy } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

const _c0 = ["ngx-charts-svg-radial-gradient", ""];
function SvgRadialGradientComponent__svg_stop_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵnamespaceSVG();
    ɵngcc0.ɵɵelement(0, "stop");
} if (rf & 2) {
    const stop_r1 = ctx.$implicit;
    ɵngcc0.ɵɵstyleProp("stop-color", stop_r1.color)("stop-opacity", stop_r1.opacity);
    ɵngcc0.ɵɵattribute("offset", stop_r1.offset + "%");
} }
export class SvgRadialGradientComponent {
    constructor() {
        this.endOpacity = 1;
        this.cx = 0;
        this.cy = 0;
    }
    get stops() {
        return this.stopsInput || this.stopsDefault;
    }
    set stops(value) {
        this.stopsInput = value;
    }
    ngOnChanges(changes) {
        this.r = '30%';
        if ('color' in changes || 'startOpacity' in changes || 'endOpacity' in changes) {
            this.stopsDefault = [
                {
                    offset: 0,
                    color: this.color,
                    opacity: this.startOpacity
                },
                {
                    offset: 100,
                    color: this.color,
                    opacity: this.endOpacity
                }
            ];
        }
    }
}
SvgRadialGradientComponent.ɵfac = function SvgRadialGradientComponent_Factory(t) { return new (t || SvgRadialGradientComponent)(); };
SvgRadialGradientComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SvgRadialGradientComponent, selectors: [["g", "ngx-charts-svg-radial-gradient", ""]], inputs: { endOpacity: "endOpacity", cx: "cx", cy: "cy", stops: "stops", color: "color", name: "name", startOpacity: "startOpacity" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], attrs: _c0, decls: 2, vars: 5, consts: [["gradientUnits", "userSpaceOnUse", 3, "id"], [3, "stop-color", "stop-opacity", 4, "ngFor", "ngForOf"]], template: function SvgRadialGradientComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(0, "radialGradient", 0);
        ɵngcc0.ɵɵtemplate(1, SvgRadialGradientComponent__svg_stop_1_Template, 1, 5, "stop", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("id", ctx.name);
        ɵngcc0.ɵɵattribute("cx", ctx.cx)("cy", ctx.cy)("r", ctx.r);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.stops);
    } }, directives: [ɵngcc1.NgForOf], encapsulation: 2, changeDetection: 0 });
SvgRadialGradientComponent.propDecorators = {
    color: [{ type: Input }],
    name: [{ type: Input }],
    startOpacity: [{ type: Input }],
    endOpacity: [{ type: Input }],
    cx: [{ type: Input }],
    cy: [{ type: Input }],
    stops: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SvgRadialGradientComponent, [{
        type: Component,
        args: [{
                selector: 'g[ngx-charts-svg-radial-gradient]',
                template: `
    <svg:radialGradient [id]="name" [attr.cx]="cx" [attr.cy]="cy" [attr.r]="r" gradientUnits="userSpaceOnUse">
      <svg:stop
        *ngFor="let stop of stops"
        [attr.offset]="stop.offset + '%'"
        [style.stop-color]="stop.color"
        [style.stop-opacity]="stop.opacity"
      />
    </svg:radialGradient>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush
            }]
    }], function () { return []; }, { endOpacity: [{
            type: Input
        }], cx: [{
            type: Input
        }], cy: [{
            type: Input
        }], stops: [{
            type: Input
        }], color: [{
            type: Input
        }], name: [{
            type: Input
        }], startOpacity: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL3N3aW1sYW5lL25neC1jaGFydHMvc3JjL2xpYi9jb21tb24vc3ZnLXJhZGlhbC1ncmFkaWVudC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsdUJBQXVCLEVBQWlCLE1BQU0sZUFBZSxDQUFDOzs7Ozs7Ozs7Ozs7O0FBaUJwRyxNQUFNLE9BQU8sMEJBQTBCO0FBQUcsSUFkMUM7QUFDRyxRQWlCUSxlQUFVLEdBQUcsQ0FBQyxDQUFDO0FBQzFCLFFBQVcsT0FBRSxHQUFXLENBQUMsQ0FBQztBQUMxQixRQUFXLE9BQUUsR0FBVyxDQUFDLENBQUM7QUFDMUIsSUFnQ0EsQ0FBQztBQUNELElBaENFLElBQ0ksS0FBSztBQUFLLFFBQ1osT0FBTyxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUM7QUFDaEQsSUFBRSxDQUFDO0FBQ0gsSUFDRSxJQUFJLEtBQUssQ0FBQyxLQUFpQjtBQUM3QixRQUFJLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO0FBQzVCLElBQUUsQ0FBQztBQUNILElBTUUsV0FBVyxDQUFDLE9BQXNCO0FBQUksUUFDcEMsSUFBSSxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7QUFDbkIsUUFBSSxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUksY0FBYyxJQUFJLE9BQU8sSUFBSSxZQUFZLElBQUksT0FBTyxFQUFFO0FBQ3BGLFlBQU0sSUFBSSxDQUFDLFlBQVksR0FBRztBQUMxQixnQkFBUTtBQUNSLG9CQUFVLE1BQU0sRUFBRSxDQUFDO0FBQ25CLG9CQUFVLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztBQUMzQixvQkFBVSxPQUFPLEVBQUUsSUFBSSxDQUFDLFlBQVk7QUFDcEMsaUJBQVM7QUFDVCxnQkFBUTtBQUNSLG9CQUFVLE1BQU0sRUFBRSxHQUFHO0FBQ3JCLG9CQUFVLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztBQUMzQixvQkFBVSxPQUFPLEVBQUUsSUFBSSxDQUFDLFVBQVU7QUFDbEMsaUJBQVM7QUFDVCxhQUFPLENBQUM7QUFDUixTQUFLO0FBQ0wsSUFBRSxDQUFDO0FBQ0g7c0RBckRDLFNBQVMsU0FBQyxrQkFDVCxRQUFRLEVBQUU7Q0FBbUMsa0JBQzdDLFFBQVEsRUFBRSx3VUFTVCxrQkFDRCxlQUFlLEVBQUUsdUJBQXVCLENBQUMsTUFBTSxjQUNoRDs7Ozs7Ozs7OzsrRUFDSTtBQUFDO0FBQThDLG9CQUNqRCxLQUFLO0FBQUssbUJBQ1YsS0FBSztBQUFLLDJCQUNWLEtBQUs7QUFBSyx5QkFDVixLQUFLO0FBQUssaUJBQ1YsS0FBSztBQUFLLGlCQUNWLEtBQUs7QUFBSyxvQkFFVixLQUFLO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEdyYWRpZW50IH0gZnJvbSAnLi90eXBlcy9ncmFkaWVudC5pbnRlcmZhY2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdnW25neC1jaGFydHMtc3ZnLXJhZGlhbC1ncmFkaWVudF0nLFxuICB0ZW1wbGF0ZTogYFxuICAgIDxzdmc6cmFkaWFsR3JhZGllbnQgW2lkXT1cIm5hbWVcIiBbYXR0ci5jeF09XCJjeFwiIFthdHRyLmN5XT1cImN5XCIgW2F0dHIucl09XCJyXCIgZ3JhZGllbnRVbml0cz1cInVzZXJTcGFjZU9uVXNlXCI+XG4gICAgICA8c3ZnOnN0b3BcbiAgICAgICAgKm5nRm9yPVwibGV0IHN0b3Agb2Ygc3RvcHNcIlxuICAgICAgICBbYXR0ci5vZmZzZXRdPVwic3RvcC5vZmZzZXQgKyAnJSdcIlxuICAgICAgICBbc3R5bGUuc3RvcC1jb2xvcl09XCJzdG9wLmNvbG9yXCJcbiAgICAgICAgW3N0eWxlLnN0b3Atb3BhY2l0eV09XCJzdG9wLm9wYWNpdHlcIlxuICAgICAgLz5cbiAgICA8L3N2ZzpyYWRpYWxHcmFkaWVudD5cbiAgYCxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgU3ZnUmFkaWFsR3JhZGllbnRDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBjb2xvcjogc3RyaW5nO1xuICBASW5wdXQoKSBuYW1lOiBzdHJpbmc7XG4gIEBJbnB1dCgpIHN0YXJ0T3BhY2l0eTogbnVtYmVyO1xuICBASW5wdXQoKSBlbmRPcGFjaXR5ID0gMTtcbiAgQElucHV0KCkgY3g6IG51bWJlciA9IDA7XG4gIEBJbnB1dCgpIGN5OiBudW1iZXIgPSAwO1xuXG4gIEBJbnB1dCgpXG4gIGdldCBzdG9wcygpOiBHcmFkaWVudFtdIHtcbiAgICByZXR1cm4gdGhpcy5zdG9wc0lucHV0IHx8IHRoaXMuc3RvcHNEZWZhdWx0O1xuICB9XG5cbiAgc2V0IHN0b3BzKHZhbHVlOiBHcmFkaWVudFtdKSB7XG4gICAgdGhpcy5zdG9wc0lucHV0ID0gdmFsdWU7XG4gIH1cblxuICByOiBzdHJpbmc7XG5cbiAgcHJpdmF0ZSBzdG9wc0lucHV0OiBHcmFkaWVudFtdO1xuICBwcml2YXRlIHN0b3BzRGVmYXVsdDogR3JhZGllbnRbXTtcblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgdGhpcy5yID0gJzMwJSc7XG4gICAgaWYgKCdjb2xvcicgaW4gY2hhbmdlcyB8fCAnc3RhcnRPcGFjaXR5JyBpbiBjaGFuZ2VzIHx8ICdlbmRPcGFjaXR5JyBpbiBjaGFuZ2VzKSB7XG4gICAgICB0aGlzLnN0b3BzRGVmYXVsdCA9IFtcbiAgICAgICAge1xuICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICBvcGFjaXR5OiB0aGlzLnN0YXJ0T3BhY2l0eVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgb2Zmc2V0OiAxMDAsXG4gICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IsXG4gICAgICAgICAgb3BhY2l0eTogdGhpcy5lbmRPcGFjaXR5XG4gICAgICAgIH1cbiAgICAgIF07XG4gICAgfVxuICB9XG59XG4iXX0=